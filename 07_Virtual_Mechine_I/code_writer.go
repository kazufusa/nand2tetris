package vmI

import "os"

// RAM addresses
// 0-15     Sixteen virtual registers
// 16-255   Static variables
// 256-2047 Stack

// SP          RAM[0]      Stack Pointer
// LCL         RAM[1]      Base address of the local segment
// ARG         RAM[2]      Base address of the argument segment
// THIS        RAM[3]      Base address of the this segment
// THAT        RAM[4]      Base address of the that segment
// TEMP        RAM[5-12]   holds the temp segment
// R13,R14,R15 RAM[13-15]  if the assembly code generated by the VM translator needs variables, it can use these registers

const (
	// pop y to D
	popValue = "@SP\nM=M-1\n@SP\nA=M\nD=M\n"
	// pop y to D and x to A
	popTwoValues = popValue + "@SP\nM=M-1\n@SP\nA=M\nA=M\n"
	// increment SP
	incrementSP = "@SP\nM=M+1\n"

	// add: x + y
	add = popTwoValues + "D=D+A\n@SP\nA=M\nM=D\n" + incrementSP
	// sub: x - y
	sub = popTwoValues + "D=A-D\n@SP\nA=M\nM=D\n" + incrementSP
	// neg: - y
	neg = popValue + "D=-D\n@SP\nA=M\nM=D\n" + incrementSP
	// and: x And y
	and = popTwoValues + "D=D&A\n@SP\nA=M\nM=D\n" + incrementSP
	// or x or y
	or = popTwoValues + "D=D|A\n@SP\nA=M\nM=D\n" + incrementSP
	// not Not y
	not = popValue + "D=!D\n@SP\nA=M\nM=D\n" + incrementSP
)

type CodeWriter struct {
	f   string
	buf string
}

func NewCodeWrite(f string) *CodeWriter {
	return &CodeWriter{f: f, buf: ""}
}

func (c *CodeWriter) writeArithmetic(command string) {
	switch command {
	case "add":
		c.buf += add
	case "sub":
		c.buf += sub
	case "neg":
		c.buf += neg
	case "eq":
		// x == y

		// pop y to D and x to A
		c.buf += popTwoValues +
			`
			D=D-A
			A=0
			@EQ
			D:JNE
			A=-1
			(EQ)
			D=A
			@SP
			A=M
			M=D
			` +
			incrementSP
	case "gt":
		// x > y

		// pop y to D and x to A
		c.buf += popTwoValues +
			`
			D=A-D
			A=0
			@GT
			D:JGT
			A=-1
			(GT)
			D=A
			@SP
			A=M
			M=D
			` +
			incrementSP
	case "lt":
		// x < y

		// pop y to D and x to A
		c.buf += popTwoValues +
			`
			D=A-D
			A=0
			@LT
			D:JLT
			A=-1
			(LT)
			D=A
			@SP
			A=M
			M=D
			` +
			incrementSP
	case "and":
		c.buf += and
	case "or":
		c.buf += or
	case "not":
		c.buf += not
	}

}

func (c *CodeWriter) writePushPop(command Command, segment string, index int) {}

func (c *CodeWriter) close() error {
	return os.WriteFile(c.f, []byte(c.buf), 0777)
}
