package vmI

import (
	"errors"
	"regexp"
	"strconv"
	"strings"
)

// Specification
// - Push/pop commands transfer data between the stack and memory segments
// - Arithmetic-logical commands perform arithmetic and logical operations
//   - add, sub, neg, eq, gt, lt, and, or, no
// ( - Branching commands facilitate conditional and unconditional branching operations )
// ( - Function commands facilitate function call-and-return operations )

// RAM addresses
// 0-15     Sixteen virtual registers
// 16-255   Static variables
// 256-2047 Stack

// SP          RAM[0]      Stack Pointer
// LCL         RAM[1]      Base address of the local segment
// ARG         RAM[2]      Base address of the argument segment
// THIS        RAM[3]      Base address of the this segment
// THAT        RAM[4]      Base address of the that segment
// TEMP        RAM[5-12]   holds the temp segment
// R13,R14,R15 RAM[13-15]  if the assembly code generated by the VM translator needs variables, it can use these registers

type Command int

const (
	C_ALITHMETIC Command = iota
	C_PUSH
	C_POP
	C_LABEL
	C_GOTO
	C_IF
	C_FUNCTION
	C_RETURN
	C_CALL
)

var (
	reComment      = regexp.MustCompile(`//[^\n]*`)
	reForwardSpace = regexp.MustCompile(`(?m)^\s*`)
	reSpace        = regexp.MustCompile(`(?m)^\s+`)
)

type Parser struct {
	lines []string
	count int
}

func NewParser(s string) (*Parser, error) {
	s = reComment.ReplaceAllString(s, "")
	s = reForwardSpace.ReplaceAllString(s, "")
	s = reSpace.ReplaceAllString(s, " ")
	s = strings.ReplaceAll(s, "\r", "")
	parser := Parser{}
	parser.lines = strings.Split(s, "\n")
	for i := len(parser.lines) - 1; i >= 0; i-- {
		if parser.lines[i] == "" {
			parser.lines = append(parser.lines[:i], parser.lines[i+1:]...)
		}
	}
	return &parser, nil
}

func (p *Parser) hasMoreLines() bool {
	return p.count < (len(p.lines) - 2)
}

func (p *Parser) advance() {
	p.count++
}

func (p *Parser) commandType() (cmd Command, err error) {
	args := strings.Split(p.lines[p.count], " ")
	switch args[0] {
	case "add", "sub", "neg", "eq", "gt", "lt", "and", "or", "no":
		return C_ALITHMETIC, nil
	case "push":
		return C_PUSH, nil
	case "pop":
		return C_POP, nil
	}

	return C_POP, errors.New("invalid command")
}

func (p *Parser) arg1() (string, error) {
	args := strings.Split(p.lines[p.count], " ")
	if cmd, err := p.commandType(); err == nil && cmd == C_ALITHMETIC {
		return args[0], nil
	}
	if len(args) < 2 {
		return "", errors.New("arg1 is not exists")
	}
	return args[1], nil
}

func (p *Parser) arg2() (int, error) {
	args := strings.Split(p.lines[p.count], " ")
	if len(args) == 3 {
		return strconv.Atoi(args[2])
	}
	return 0, errors.New("arg2 is not exists")
}
