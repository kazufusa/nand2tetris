> We will use this example to demonstrate that even the most trivial high-level progoram has much more to it than meets the eye.

> Once we get a programmer-oriented taste of the high-level jack language, we will be prepared to start the journey of realizing the language by building a virtual machine, a compiler, and an operating system.

> Indeed, the beauty of high-level programming languages, and that of well-designed abstractions in general, is that they permit using them in a state of blissful ignorance.

You may be wondering why you hove to bother about this elusive behind-the-scenes scene.
Didn't we just say that you can use high-level languages without worrying about how this work?
There are at least two reasons why.
First, the more you delve into low-level system internals, the more sophisticated high-level programmer you become.
In particular, you learn how to write high-level code that exploits the hardware and the OS cleverly and efficient and how to avoid baffling bugs like memory leaks.

Second, by getting your hand dirty and developing the system internals yourself, you will discover some of the most beautiful and powerful algorithms and data structures in applied computer science.
Importantly, the ideas and techniques that will unfold in part II are not limited compilers and operatiog systems.
Rather, they are the building blocks of numerous software systems and applications that will accompany you throughout your career.

Suppose we want to represent and manipulate points on plane.
